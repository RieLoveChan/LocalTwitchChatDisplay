<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Chat Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif; /* Will be overridden by .controls for the panel */
            background: #0e0e10; /* Page background, chat messages are on this */
            color: #efeff1; /* Default text color for page, chat messages use this */
            height: 100vh;
            overflow: hidden;
        }

        .controls {
            position: fixed;
            top: 10px;
            left: 10px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background: rgba(245, 245, 247, 0.85); /* Light, translucent background */
            color: #333; /* Dark text for controls */
            padding: 20px;
            border-radius: 12px; /* Softer corners */
            z-index: 1000;
            display: flex;
            gap: 15px; /* Increased gap */
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* Subtle shadow */
        }

        /* General reset for form elements within .controls, more specific rules follow */
        .controls input, .controls select, .controls button {
            font-size: 15px; /* Base font size for controls */
            border-radius: 8px; /* Consistent corner rounding */
            /* Removing old general background/color, will be set by specific rules */
        }

        .controls button {
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            background-color: #e0e0e0; /* Light gray for secondary/default buttons */
            color: #333;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .controls button:hover {
            background-color: #d5d5d5;
        }

        .controls button:active {
            transform: scale(0.98);
            background-color: #cccccc;
        }
        
        #connectBtn {
            background-color: #007aff; /* iOS blue */
            color: white;
            font-weight: 500;
        }

        #connectBtn:hover {
            background-color: #005ecb; /* Darker blue on hover */
        }

        .controls button:disabled {
            background-color: #f0f0f0; /* Lighter gray for disabled */
            color: #aaa; /* Muted text color */
            cursor: not-allowed;
            transform: scale(1); /* Ensure no active transform state is stuck */
        }
        
        .controls input[type="text"], 
        .controls input[type="password"], 
        .controls select {
            border: 1px solid #ccc;
            padding: 10px 12px;
            background-color: #fff; /* White background for inputs */
            color: #333;
        }

        .controls input[type="text"]:focus,
        .controls input[type="password"]:focus,
        .controls select:focus {
            border-color: #007aff;
            box-shadow: 0 0 0 2px rgba(0,122,255,0.3);
            outline: none;
        }

        .status {
            color: #28a745; /* Green for connected */
            font-size: 14px; /* Slightly larger for better visibility */
            font-weight: 500;
        }

        .status.disconnected {
            color: #dc3545; /* Red for disconnected */
        }

        /* Vertical Scrolling (Default) */
        #chatContainer {
            position: fixed;
            bottom: 0;
            transition: transform 0.2s ease-out; 
            left: 0;
            right: 0;
            height: calc(100vh - 80px);
            overflow-y: auto; /* Still needed for when content exceeds height */
            overflow-x: hidden;
            padding: 20px;
            display: flex;
            flex-direction: column-reverse; /* Key change for vertical scroll */
            gap: 8px;
        }

        /* Default animation for messages in vertical mode, if not overridden by specific style */
        #chatContainer:not(.horizontal):not(.nico) .chat-message {
            animation: smoothArrival 0.3s ease-out;
        }


        /* Horizontal Scrolling */
        #chatContainer.horizontal {
            bottom: 20px;
            left: 0;
            right: 0;
            height: auto;
            max-height: 200px;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 20px;
            display: flex;
            flex-direction: row;
            gap: 12px;
            white-space: nowrap;
        }

        #chatContainer.horizontal .chat-message {
            flex-shrink: 0;
            min-width: 200px;
            max-width: 400px;
            white-space: normal;
        }

        /* Transparent Bubble Style (Snoopy Comics Themed) */
        .chat-message.bubble {
            background: #FEFDF5; /* Opaque off-white/cream */
            color: #222222; /* Dark text for Snoopy bubbles */
            border: 1px solid #333333; /* Thin dark line border */
            /* backdrop-filter: blur(10px); /* Removed */
            /* Dynamic properties like padding, margin, radius, max-width will be overridden by JS controls */
            padding: 12px 16px; /* Default padding */
            margin: 4px 0;     /* Default margin (spacing) */
            border-radius: 20px;/* Default radius */
            max-width: 80%;    /* Default max-width */
            word-wrap: break-word;
            animation-name: snoopyPopIn;
            animation-duration: 0.4s;
            animation-timing-function: ease-out;
        }

        /* Horizontal animation for horizontal scrolling */
        #chatContainer.horizontal .chat-message.bubble {
            animation: slideInHorizontal 0.3s ease-out;
            margin: 0 4px;
        }

        /* Vivid Color Style */
        .chat-message.vivid {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            padding: 10px 14px;
            margin: 4px 0;
            max-width: 85%;
            word-wrap: break-word;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            border-left: 4px solid #9146ff;
            animation: slideIn 0.3s ease-out;
        }

        #chatContainer.horizontal .chat-message.vivid {
            animation: slideInHorizontal 0.3s ease-out;
            margin: 0 4px;
        }

        .username {
            font-weight: bold;
            margin-right: 8px;
        }

        .message-text {
            display: inline;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideInHorizontal {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Style-specific adjustments */
        .style-controls {
            background: rgba(230, 230, 230, 0.85); /* Slightly darker than main controls panel */
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px; /* Keep some spacing */
            display: none; /* Hidden by default */
            width: 100%; /* Make it take full width of the controls flex item it's in */
            box-sizing: border-box;
        }

        .style-controls.active {
            display: block;
        }

        /* Labels within .controls and .style-controls should be dark */
        .controls label, .style-controls label {
            color: #333; /* Ensure all labels are dark */
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
        }
        
        /* Styling for range inputs (sliders) */
        .style-controls input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: #ddd; /* Track color */
            height: 8px;
            border-radius: 4px;
            width: 120px; /* Keep original width or adjust as needed */
            margin: 0 10px;
        }

        .style-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #007aff; /* iOS blue thumb */
            border-radius: 50%;
            cursor: pointer;
        }

        .style-controls input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #007aff; /* iOS blue thumb */
            border-radius: 50%;
            cursor: pointer;
            border: none; /* Important for Firefox */
        }

        /* Text value display next to sliders */
        .style-controls span {
            min-width: 40px;
            text-align: right;
            color: #007aff; /* iOS blue for accent */
            font-weight: 500;
        }

        .toggle-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: transparent; 
            padding: 0; 
            border-radius: 8px; /* Keep radius in case a border is added later directly to container */
            z-index: 1001; /* Ensure it's above the main controls panel */
        }

        .toggle-controls button {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background: transparent;
            border: none;
            color: #bbb; /* Light color for icon */
            padding: 5px; /* Adjust as needed */
            font-size: 24px; /* Slightly larger icon for better clickability without background */
            line-height: 1; 
            cursor: pointer;
            transition: transform 0.1s ease, color 0.2s ease;
            /* Remove box-shadow if any was implicitly inherited or applied */
            box-shadow: none;
        }
        .toggle-controls button:hover {
            color: #fff; /* Brighter on hover */
            transform: scale(1.1); /* Slight zoom on hover */
        }
        .toggle-controls button:active {
            transform: scale(0.95); /* Slightly smaller on click */
            color: #aaa; /* Dim slightly on click or keep #fff */
        }

        .emote {
            display: inline-block;
            vertical-align: middle;
            max-height: 28px;
        }

        /* Scrolling direction indicator (CSS class removed as element is removed) */
    
/* Pastel Style */
.chat-message.pastel {
    background: #ffe4f0;
    border: 2px solid #ffd6ec;
    border-radius: 20px;
    color: #8a4f7d;
    font-family: 'Comic Sans MS', cursive, sans-serif;
    padding: 14px 18px;
    animation: fade-left 1s ease-out;
}

/* Twitch Style */
.chat-message.twitch {
    background: #18181b;
    border-left: 4px solid #9146ff;
    border-radius: 4px;
    padding: 12px 16px;
    font-family: 'Arial', sans-serif;
    color: #fff;
    animation: fade-right 1s ease-out;
}

/* PNM Style */
.chat-message.pnm {
    background: yellow;
    border: 3px solid blue;
    border-radius: 12px;
    padding: 10px 16px;
    color: black;
    animation: fade-down 1s ease-out;
}

/* Fade Animations */
@keyframes fade-left {
    from { opacity: 0; transform: translateX(-30px); }
    to { opacity: 1; transform: translateX(0); }
}
@keyframes fade-right {
    from { opacity: 0; transform: translateX(30px); }
    to { opacity: 1; transform: translateX(0); }
}
@keyframes fade-up {
    from { opacity: 0; transform: translateY(-30px); }
    to { opacity: 1; transform: translateY(0); }
}
@keyframes fade-down {
    from { opacity: 0; transform: translateY(30px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Light Style */
.chat-message.light {
    background: #f0f0f0;
    border: 1px solid #cccccc;
    border-radius: 6px;
    padding: 10px 14px;
    margin: 4px 0;
    max-width: 85%;
    word-wrap: break-word;
    color: #333333;
    animation: fade-up 0.5s ease-out;
}

.chat-message.light .username {
    color: #555555;
    font-weight: bold;
}

#chatContainer.horizontal .chat-message.light {
    animation: slideInHorizontal 0.3s ease-out; /* Or a specific horizontal animation if preferred */
    margin: 0 4px;
}

.message-timestamp {
    color: #999999; /* Default light gray for dark themes */
    font-size: 0.8em;
    margin-right: 6px;
    display: none; /* Initially hidden, controlled by JS */
}

.chat-message.light .message-timestamp {
    color: #555555; /* Darker gray for light theme */
}

/* Nico Scroll Style CSS */
#chatContainer.nico {
    overflow: hidden; /* Prevent messages from showing outside the container */
    /* position: relative; /* Not strictly needed as #chatContainer is position:fixed */
}

#chatContainer.nico .chat-message {
    position: absolute;
    /* 'left' will be set by JavaScript to start off-screen right */
    /* 'top' will be set by JavaScript */
    white-space: nowrap;
    padding: 5px 10px;
    text-shadow: 0 0 3px black, 0 0 3px black; /* Emphasize shadow for readability */
    font-size: 22px; /* Slightly larger default */
    animation-name: nico-scroll-animation; /* Renamed for clarity */
    animation-timing-function: linear;
    animation-duration: 8s; /* Default, can be varied by JS */
}

@keyframes nico-scroll-animation { /* Renamed */
    from {
        transform: translateX(0%); /* Starts at the 'left' position set by JS */
    }
    to {
        /* Moves left by a large amount to ensure it crosses the screen.
           -130vw means 130% of the viewport width to the left. */
        transform: translateX(-130vw); 
    }
}

@keyframes smoothArrival {
    from {
        opacity: 0;
        transform: translateY(20px); /* Start slightly lower */
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes snoopyPopIn {
    0% {
        transform: scale(0.3);
        opacity: 0;
    }
    60% {
        transform: scale(1.05); /* Overshoot */
        opacity: 1;
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

/* Nico Speed Controls Styling */
#nicoControls {
    /* display: none; /* Initially hidden, shown by JS when Nico scroll is active - REMOVED, will inherit from .style-controls */
    /* Similar styling to .style-controls for consistency, or a general class can be made */
    background: rgba(230, 230, 230, 0.85); /* Match .style-controls background */
    padding: 10px 15px;
    border-radius: 8px;
    margin-top: 10px;
    width: 100%; /* Or appropriate width */
    box-sizing: border-box;
}
#nicoControls label { /* Ensure label styling matches others */
    color: #333;
    font-size: 14px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 8px 0;
}
#nicoControls input[type="range"] { /* Ensure slider styling matches others */
    /* Copy styles from .style-controls input[type="range"] or create a shared class */
    -webkit-appearance: none;
    appearance: none;
    background: #ddd;
    height: 8px;
    border-radius: 4px;
    width: 120px; /* Or adjust */
    margin: 0 10px;
}
#nicoControls input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: #007aff;
    border-radius: 50%;
    cursor: pointer;
}
#nicoControls input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: #007aff;
    border-radius: 50%;
    cursor: pointer;
    border: none;
}
#nicoControls span { /* Ensure span styling for value matches others */
    min-width: 40px;
    text-align: right;
    color: #007aff;
    font-weight: 500;
}
</style>
</head>
<body>
    <div class="toggle-controls">
        <button onclick="toggleControls()" title="Toggle Controls">üéõÔ∏è</button>
    </div>

    <div class="controls" id="controls">
        <input type="text" id="channelInput" placeholder="Channel name" list="channelSuggestions">
        <datalist id="channelSuggestions">
            <option value="nstgaming_">
            <option value="jano_manx">
            <option value="zfg1">
        </datalist>

        <input type="password" id="oauthInput" placeholder="OAuth Token (oauth:xxxxxx)">
        <input type="text" id="nickInput" placeholder="Nickname (optional)">

        <!-- User Help Text for OAuth Token -->
        <div style="width: 100%; margin-top: 5px; margin-bottom: 5px; order: 1;"> <!-- Wrapper div for better layout and order -->
            <p style="font-size: 12px; color: #555;"> <!-- Updated color for light panel -->
              <strong>How to get an OAuth Token:</strong> For Twitch chat, you need an OAuth token. You can generate one from sites like
              <a href="https://twitchtokengenerator.com" target="_blank" style="color: #007aff;">twitchtokengenerator.com</a>. <!-- Updated link color -->
              Recommended scope: <code>chat:read</code>. Ensure the token is prefixed with "oauth:".
            </p>
        </div>
        
        <button id="connectBtn" onclick="connectToChannel()">Connect</button>
        
        <select id="styleSelect" onchange="changeStyle()">
            <option value="bubble">Bubble</option>
<option value="pastel">Pastel</option>
<option value="twitch">Twitch</option>
<option value="pnm">PNM</option>
            <option value="vivid">Vivid Colors</option>
            <option value="light">Light</option>
        </select>

        <select id="scrollDirection" onchange="changeScrollDirection()">
            <option value="vertical">Vertical Scroll</option>
            <option value="horizontal">Horizontal Scroll</option>
            <option value="nico">Nico Scroll</option>
        </select>
        
        <span class="status" id="status">Disconnected</span>
        
        <button onclick="clearChat()">Clear Chat</button>

        <div><input type="checkbox" id="showTimestamps" onchange="toggleAllTimestamps(this.checked)"> <label for="showTimestamps">Show Timestamps</label></div> <!-- Removed inline style, will be handled by .controls label -->
        
        <div class="style-controls" id="generalStyleControls">
            <label for="messageOpacity">Msg Opacity: <input type="range" id="messageOpacity" min="0" max="100" value="100" step="5" onchange="updateMessageOpacity()"> <span id="messageOpacityValue">100%</span></label>
            <label>Corner Radius: <input type="range" id="generalRadius" min="5" max="30" value="20" onchange="updateGeneralStyle()"><span id="generalRadiusValue">20px</span></label>
            <label>Max Width: <input type="range" id="generalMaxWidth" min="50" max="100" value="80" onchange="updateGeneralStyle()"><span id="generalMaxWidthValue">80%</span></label>
            <label>Vertical Padding: <input type="range" id="generalVPadding" min="5" max="25" value="12" onchange="updateGeneralStyle()"><span id="generalVPaddingValue">12px</span></label>
            <label>Horizontal Padding: <input type="range" id="generalHPadding" min="8" max="30" value="16" onchange="updateGeneralStyle()"><span id="generalHPaddingValue">16px</span></label>
            <label>Message Spacing: <input type="range" id="generalSpacing" min="2" max="15" value="8" onchange="updateGeneralStyle()"><span id="generalSpacingValue">8px</span></label>
        </div>

        <div class="style-controls active" id="scaleControls">
            <label for="chatScale">Chat Scale: <input type="range" id="chatScale" min="50" max="150" value="100" step="10" onchange="updateChatScale()"> <span id="chatScaleValue">100%</span></label>
        </div>
        
        <div class="style-controls" id="vividControls">
            <label>Shadow Intensity: <input type="range" id="vividShadow" min="0" max="50" value="15" onchange="updateVividStyle()"><span id="vividShadowValue">15px</span></label>
            <label>Border Width: <input type="range" id="vividBorder" min="0" max="8" value="4" onchange="updateVividStyle()"><span id="vividBorderValue">4px</span></label>
        </div>

        <div class="style-controls" id="nicoControls"> <!-- This will inherit .style-controls styling -->
            <label for="nicoSpeed">Nico Speed: <input type="range" id="nicoSpeed" min="3" max="15" value="8" step="1" onchange="updateNicoSpeed()"> <span id="nicoSpeedValue">8s</span></label>
        </div>
    </div>

    <div id="chatContainer"></div>

    <script>
        // --- Global Variables ---
        let ws = null; // WebSocket connection object. Null when disconnected.
        let currentChannel = ''; // Stores the name of the Twitch channel currently connected to.
        let currentStyle = 'bubble'; // Holds the active chat message style (e.g., 'bubble', 'vivid'). Default is 'bubble'.
        let controlsVisible = true; // Boolean to track if the main control panel is visible.
        let scrollDirection = 'vertical'; // Determines chat scrolling direction ('vertical' or 'horizontal').

        /**
         * Initializes the application after the DOM is fully loaded.
         * - Sets a default channel.
         * - Updates UI elements based on current settings (styles, scroll direction, timestamps).
         * - Initializes style control values.
         * - Automatically connects to the default channel.
         */
        window.addEventListener('load', () => {
            document.getElementById('channelInput').value = 'nstgaming_'; // Default channel
            document.getElementById('styleSelect').value = currentStyle; // Set dropdown to currentStyle
            updateStyleControls(); // Show controls for the default style
            updateScrollDirection(); // Apply default scroll direction
            // Initialize display values for style-specific sliders
            updateGeneralStyle(); 
            updateVividStyle();
            updateNicoSpeed(); // Initialize Nico speed display
            updateChatScale(); // Initialize chat scale
            updateMessageOpacity(); // Initialize message opacity
            // Set initial timestamp visibility based on the checkbox state (default: hidden)
            toggleAllTimestamps(document.getElementById('showTimestamps').checked); 
            connectToChannel(); // Attempt to connect to the default channel
        });

        /**
         * Toggles the visibility of the main controls panel.
         */
        function toggleControls() {
            const controls = document.getElementById('controls');
            controlsVisible = !controlsVisible; // Flip the visibility state
            controls.style.display = controlsVisible ? 'flex' : 'none'; // Apply display style
        }

        /**
         * Updates the global opacity for all chat messages based on the slider.
         */
        function updateMessageOpacity() {
            const opacitySlider = document.getElementById('messageOpacity');
            const opacityValueDisplay = document.getElementById('messageOpacityValue');

            if (opacitySlider && opacityValueDisplay) {
                const opacityValue = parseInt(opacitySlider.value); // Value from 0-100
                opacityValueDisplay.textContent = opacityValue + '%';

                const newOpacity = opacityValue / 100; // Convert to 0.0 - 1.0
                
                // Apply this opacity to all chat messages globally
                // Using !important to ensure it overrides any specific theme's opacity setting on the message div itself.
                const styleContent = `.chat-message { opacity: ${newOpacity} !important; }`;
                updateDynamicStyle('globalMessageOpacityStyle', styleContent);
            }
        }

        /**
         * Updates the chat container's scale based on the slider and updates the display value.
         */
        function updateChatScale() {
            const scaleSlider = document.getElementById('chatScale');
            const chatContainer = document.getElementById('chatContainer');
            const scaleValueDisplay = document.getElementById('chatScaleValue');

            if (scaleSlider && chatContainer && scaleValueDisplay) {
                const scale = parseFloat(scaleSlider.value) / 100; // Convert percentage to decimal (e.g., 100 -> 1.0)
                scaleValueDisplay.textContent = scaleSlider.value + '%';
                chatContainer.style.transform = `scale(${scale})`;
                chatContainer.style.transformOrigin = 'bottom left'; // Always use bottom left
            }
        }

        /**
         * Updates the display value for the Nico Scroll speed slider.
         */
        function updateNicoSpeed() {
            const speedSlider = document.getElementById('nicoSpeed');
            if (speedSlider) { 
                const speedValueDisplay = document.getElementById('nicoSpeedValue');
                const duration = speedSlider.value;
                if (speedValueDisplay) {
                    speedValueDisplay.textContent = duration + 's';
                }
            }
        }

        /**
         * Called when the scroll direction dropdown changes.
         * Updates the global scrollDirection variable and applies the change.
         */
        function changeScrollDirection() {
            scrollDirection = document.getElementById('scrollDirection').value;
            updateScrollDirection();
            updateStyleControls(); // Add this line
        }

        /**
         * Applies the selected scroll direction to the chat container.
         * Updates the visual indicator for the scroll direction.
         * Re-scrolls to the latest message after changing direction.
         */
        function updateScrollDirection() {
            const container = document.getElementById('chatContainer');
            
            // Remove all direction-specific classes first
            container.classList.remove('horizontal', 'nico'); 
            // Assuming default is vertical, so no explicit 'vertical' class needed unless specific styles depend on it.

            if (scrollDirection === 'horizontal') {
                container.classList.add('horizontal');
            } else if (scrollDirection === 'nico') {
                container.classList.add('nico');
            }
            // else it's vertical (default, no class needed or a 'vertical' class if you have one)

            // For Nico mode, we might clear existing non-Nico messages or let them be.
            // For now, changing mode will not automatically clear messages from other modes.
            // scrollToLatest might not be relevant for Nico mode, but doesn't harm.
            setTimeout(scrollToLatest, 100); 
        }

        /**
         * Scrolls the chat container to the latest message.
         * Adapts to both vertical and horizontal scroll directions.
         * Does nothing if scrollDirection is 'nico'.
         */
        function scrollToLatest() {
            if (scrollDirection === 'nico') return; // No scrolling in Nico mode

            const container = document.getElementById('chatContainer');
            if (scrollDirection === 'horizontal') {
                container.scrollLeft = container.scrollWidth; // Scroll to the far right
            } else {
                container.scrollTop = container.scrollHeight; // Scroll to the bottom
            }
        }

        /**
         * Connects to the specified Twitch channel via WebSocket.
         * Handles OAuth token and nickname input, providing defaults if necessary.
         * Sets up WebSocket event listeners (onopen, onmessage, onclose, onerror).
         */
        function connectToChannel() {
            const channel = document.getElementById('channelInput').value.trim().toLowerCase();
            if (!channel) {
                alert('Please enter a channel name');
                return;
            }

            const connectButton = document.getElementById('connectBtn');
            connectButton.textContent = 'Connecting...';
            connectButton.disabled = true;

            // Close existing connection if any
            if (ws) {
                ws.close();
            }

            currentChannel = channel; // Store the current channel name
            
            // Establish WebSocket connection to Twitch IRC
            ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
            
            /**
             * Called when the WebSocket connection is successfully opened.
             * Handles authentication with Twitch IRC using OAuth token and nickname.
             */
            ws.onopen = () => {
                // Handle OAuth token
                let oauthToken = document.getElementById('oauthInput').value.trim();
                if (oauthToken === '') {
                    oauthToken = 'SCHMOOPIIE'; // Default anonymous token if none provided
                } else if (!oauthToken.toLowerCase().startsWith('oauth:')) {
                    oauthToken = 'oauth:' + oauthToken; // Ensure 'oauth:' prefix for the token
                }

                // Handle nickname
                let nickname = document.getElementById('nickInput').value.trim();
                if (nickname === '') {
                    // Generate a random justinfan nickname if none provided
                    nickname = `justinfan${Math.floor(Math.random() * 100000)}`;
                }

                // Send authentication messages to Twitch IRC
                ws.send(`PASS ${oauthToken}`); // Send OAuth token as password
                ws.send(`NICK ${nickname}`);    // Send nickname
                ws.send(`JOIN #${channel}`);   // Join the specified channel

                updateStatus('Connected', true); // Update UI status to 'Connected'
                
                // Update the button to be a "Disconnect" button
                const connectButton = document.getElementById('connectBtn');
                connectButton.textContent = 'Disconnect';
                connectButton.onclick = disconnect; // Change onclick to call disconnect()
                connectButton.disabled = false; // Enable the button
            };

            /**
             * Called when a message is received from the WebSocket server.
             * @param {MessageEvent} event - The event object containing the message data.
             */
            ws.onmessage = (event) => {
                handleMessage(event.data); // Process incoming messages
            };

            /**
             * Called when the WebSocket connection is closed.
             * Updates UI elements to reflect the disconnected state.
             */
            ws.onclose = () => {
                updateStatus('Disconnected', false); // Update UI status
                
                // Update the button to be a "Connect" button
                const connectButton = document.getElementById('connectBtn');
                connectButton.textContent = 'Connect';
                connectButton.onclick = connectToChannel; // Change onclick back to connectToChannel()
                connectButton.disabled = false; // Ensure it's enabled

                ws = null; // Clear WebSocket object to allow for new connections
            };

            /**
             * Called when a WebSocket error occurs.
             * Logs the error and updates the UI status.
             * @param {Event} error - The error event.
             */
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('Connection Error', false); // Update UI status for error
            };
        }

        /**
         * Closes the WebSocket connection if it's open and sets ws to null.
         */
        function disconnect() {
            if (ws) {
                ws.close();
            }
            // UI updates (button text, state, onclick) are now handled by ws.onclose
        }

        /**
         * Handles raw messages received from the WebSocket.
         * Responds to PING messages to keep the connection alive.
         * Parses PRIVMSG lines to extract username and message content.
         * @param {string} data - The raw message string from the server.
         */
        function handleMessage(data) {
            const lines = data.split('\r\n'); // Twitch messages are newline separated
            
            lines.forEach(line => {
                // Twitch IRC server sends PING messages periodically.
                // Must respond with PONG to maintain the connection.
                if (line.startsWith('PING')) {
                    ws.send('PONG :tmi.twitch.tv'); 
                    return;
                }

                // Regex to parse standard Twitch chat messages (PRIVMSG).
                // Example PRIVMSG: :username!username@username.tmi.twitch.tv PRIVMSG #channel :Actual message text
                // This regex captures:
                //   Group 1: username (e.g., "someuser")
                //   Group 2: message text (e.g., "Hello world!")
                if (line.includes('PRIVMSG')) {
                    const match = line.match(/:(.+)!.+@.+\.tmi\.twitch\.tv PRIVMSG #.+ :(.+)/);
                    if (match) {
                        const [, username, message] = match; // Destructure the captured groups
                        displayMessage(username, message);   // Display the parsed message
                    }
                }
            });
        }

        /**
         * Creates and displays a new chat message in the chat container.
         * Includes username, message text, and an optional timestamp.
         * Applies the current chat style and user-specific color to the username.
         * @param {string} username - The sender's username.
         * @param {string} message - The chat message content.
         */
        function displayMessage(username, message) {
            const chatContainer = document.getElementById('chatContainer'); // Get reference to chat container
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${currentStyle}`;

            const usernameSpan = document.createElement('span');
            usernameSpan.className = 'username';
            usernameSpan.textContent = username + ':';
            usernameSpan.style.color = generateUserColor(username);

            const messageSpan = document.createElement('span');
            messageSpan.className = 'message-text';
            messageSpan.textContent = ' ' + message;

            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'message-timestamp';
            timestampSpan.textContent = `[${new Date().toLocaleTimeString()}]`;
            if (document.getElementById('showTimestamps').checked) {
                timestampSpan.style.display = 'inline';
            } else {
                timestampSpan.style.display = 'none';
            }

            messageDiv.appendChild(timestampSpan);
            messageDiv.appendChild(usernameSpan);
            messageDiv.appendChild(messageSpan);

            if (scrollDirection === 'nico') {
                // Nico mode: messages scroll across the screen
                
                // Set initial position
                // A simple initial approach for 'top': percentage of container height.
                // Subtracting a fixed amount (e.g., 20px or message height estimate) can prevent messages from being cut off at the bottom.
                // For more precise positioning, one might need to append, measure, then set top.
                const randomTopPercent = Math.floor(Math.random() * 85); // 0% to 85% to leave some space at bottom
                messageDiv.style.top = randomTopPercent + '%'; 
                
                // Adjust starting position based on current chat container scale
                const scaleSlider = document.getElementById('chatScale');
                let currentScale = 1; // Default to 1 (no scale)
                if (scaleSlider) {
                    currentScale = (parseFloat(scaleSlider.value) || 100) / 100;
                }
                messageDiv.style.left = (chatContainer.offsetWidth / currentScale) + 'px'; // Start off-screen right, adjusted for scale

                // Get duration from the Nico Speed slider
                let nicoDuration = 8; // Default duration
                const nicoSpeedSlider = document.getElementById('nicoSpeed');
                if (nicoSpeedSlider) {
                    let sliderValue = parseFloat(nicoSpeedSlider.value);
                    // Validate against slider's min/max attributes if they exist, otherwise use reasonable defaults
                    const minDuration = nicoSpeedSlider.hasAttribute('min') ? parseFloat(nicoSpeedSlider.min) : 1;
                    const maxDuration = nicoSpeedSlider.hasAttribute('max') ? parseFloat(nicoSpeedSlider.max) : 30;

                    if (!isNaN(sliderValue) && sliderValue >= minDuration && sliderValue <= maxDuration) {
                        nicoDuration = sliderValue;
                    }
                }
                messageDiv.style.animationDuration = nicoDuration + 's';
                
                chatContainer.appendChild(messageDiv);

                // Listener for self-removal after animation ends
                messageDiv.addEventListener('animationend', function() {
                    if (this.parentNode) {
                        this.parentNode.removeChild(this);
                    }
                }, { once: true });
                // Message limit is implicitly handled by self-removal. No explicit count needed for Nico.

            } else {
                // Existing logic for vertical and horizontal scrolling
                if (scrollDirection === 'vertical') {
                    chatContainer.insertBefore(messageDiv, chatContainer.firstChild); // Prepend
                } else { // Horizontal or other non-Nico modes
                    chatContainer.appendChild(messageDiv);
                }
                scrollToLatest(); // Scroll to the new message

                // Limit messages to prevent memory issues for non-Nico modes
                if (scrollDirection === 'vertical') {
                    while (chatContainer.children.length > 100) {
                        chatContainer.removeChild(chatContainer.lastChild); // Oldest is last in DOM for column-reverse
                    }
                } else { // Horizontal
                    while (chatContainer.children.length > 100) {
                        chatContainer.removeChild(chatContainer.firstChild);
                    }
                }
            }
        }

        /**
         * Generates a pseudo-random color for a given username.
         * Uses a simple hashing algorithm to pick a color from a predefined list.
         * This ensures consistent coloring for the same username.
         * @param {string} username - The username to generate a color for.
         * @returns {string} A hex color code (e.g., '#ff6b6b').
         */
        function generateUserColor(username) {
            const colors = [ // Predefined list of visually distinct and pleasant colors
                '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7',
                '#dda0dd', '#98d8c8', '#ff7675', '#74b9ff', '#55a3ff',
                '#fd79a8', '#fdcb6e', '#6c5ce7', '#a29bfe', '#fd79a8'
            ];
            
            let hash = 0;
            // Simple hash function: iterate through username characters,
            // combine char codes using bitwise operations for better distribution.
            for (let i = 0; i < username.length; i++) {
                hash = username.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            // Use modulo operator to select a color from the array based on the hash.
            // Math.abs ensures the index is non-negative.
            return colors[Math.abs(hash) % colors.length]; 
        }

        /**
         * Called when the style select dropdown changes.
         * Updates the global currentStyle variable.
         * Applies the new style to all existing messages.
         * Shows/hides style-specific control panels.
         */
        function changeStyle() {
            currentStyle = document.getElementById('styleSelect').value;
            updateStyleControls(); // Show relevant controls for the new style
            
            // Update the class of all existing messages to reflect the new style.
            // This will trigger CSS changes associated with the new style class.
            const messages = document.querySelectorAll('.chat-message');
            messages.forEach(msg => {
                // Note: This replaces all classes except 'chat-message' with the new style.
                // If animation or other utility classes were added directly, they might be removed.
                // For this application, animations are tied to the style class itself.
                msg.className = `chat-message ${currentStyle}`; 
            });
        }

        /**
         * Shows or hides the style-specific control panels (e.g., for 'bubble' or 'vivid' styles).
         * Only one style control panel should be active and visible at a time.
         */
        function updateStyleControls() {
            const generalControls = document.getElementById('generalStyleControls');
            const vividControls = document.getElementById('vividControls');
            const nicoControls = document.getElementById('nicoControls');
            
            // Hide all style-specific controls first to ensure a clean state.
            vividControls.classList.remove('active');
            nicoControls.classList.remove('active'); // Ensure Nico controls are hidden by default
            
            // Activate general controls for all styles (it should always be visible if any style is selected)
            generalControls.classList.add('active');
            updateGeneralStyle(); // Update general sliders to reflect current style or apply to new style

            // Show controls for the currently selected style if specific controls exist.
            if (currentStyle === 'vivid') {
                vividControls.classList.add('active');
                updateVividStyle(); // Ensure sliders and values reflect current vivid style state.
            } 
            // Note: 'bubble' and other styles only use general controls now.
            
            // Show Nico controls only if Nico scroll direction is active
            if (scrollDirection === 'nico') {
                nicoControls.classList.add('active');
                updateNicoSpeed(); // Initialize/update speed display when shown
            }
        }

        /**
         * Toggles the visibility of all timestamps in the chat based on checkbox state.
         * Iterates through all messages and sets the display style of their timestamp elements.
         * @param {boolean} isChecked - True if timestamps should be shown, false if hidden.
         */
        function toggleAllTimestamps(isChecked) {
            const allTimestamps = document.querySelectorAll('.chat-message .message-timestamp');
            allTimestamps.forEach(ts => {
                // Set display to 'inline' to show, 'none' to hide.
                ts.style.display = isChecked ? 'inline' : 'none'; 
            });
        }
        
        /**
         * Updates the general CSS properties (radius, width, padding, spacing) for the current chat message style.
         * Gets values from corresponding sliders, updates their display values,
         * then generates a CSS string and applies it dynamically to the page.
         */
        function updateGeneralStyle() {
            // Get values from sliders
            const radius = document.getElementById('generalRadius').value;
            const width = document.getElementById('generalMaxWidth').value;
            const vPadding = document.getElementById('generalVPadding').value;
            const hPadding = document.getElementById('generalHPadding').value;
            const spacing = document.getElementById('generalSpacing').value;
            
            // Update display values next to sliders for immediate user feedback
            document.getElementById('generalRadiusValue').textContent = radius + 'px';
            document.getElementById('generalMaxWidthValue').textContent = width + '%';
            document.getElementById('generalVPaddingValue').textContent = vPadding + 'px';
            document.getElementById('generalHPaddingValue').textContent = hPadding + 'px';
            document.getElementById('generalSpacingValue').textContent = spacing + 'px';
            
            // Construct CSS rules string. Using '!important' to ensure these dynamic styles
            // override any base styles defined in the main <style> tag or specific theme styles.
            const style = `
                .chat-message.${currentStyle} {
                    border-radius: ${radius}px !important;
                    max-width: ${width}% !important;
                    padding: ${vPadding}px ${hPadding}px !important;
                }
                /* Apply margin for spacing differently for vertical vs horizontal layouts */
                #chatContainer:not(.horizontal) .chat-message.${currentStyle} {
                    margin: ${spacing / 2}px 0 !important; /* Vertical spacing (top/bottom) */
                }
                #chatContainer.horizontal .chat-message.${currentStyle} {
                    margin: 0 ${spacing / 2}px !important; /* Horizontal spacing (left/right) */
                }
            `;
            
            updateDynamicStyle('generalSharedStyle', style); // Apply the generated CSS to a <style> tag
        }

        /**
         * Updates the CSS for the 'vivid' chat message style based on slider values.
         * Similar to updateBubbleStyle, but for the 'vivid' style's specific controls.
         */
        function updateVividStyle() {
            // Get values from sliders for Vivid-specific properties
            const shadow = document.getElementById('vividShadow').value;
            const border = document.getElementById('vividBorder').value;
            
            // Update display values next to sliders
            document.getElementById('vividShadowValue').textContent = shadow + 'px';
            document.getElementById('vividBorderValue').textContent = border + 'px';
            
            // Construct CSS rules string for the 'vivid' style, only for its unique properties
            const style = `
                .chat-message.vivid {
                    box-shadow: 0 4px ${shadow}px rgba(102, 126, 234, 0.3) !important;
                    border-left: ${border}px solid #9146ff !important;
                }
            `;
            // Shared properties like border-radius, max-width, padding, margin 
            // are now handled by updateGeneralStyle() and its 'generalSharedStyle' CSS block.
            
            updateDynamicStyle('vividStyle', style); // Apply the generated CSS
        }

        /**
         * Adds or updates a <style> element in the document's <head> with the provided CSS.
         * This allows for dynamic styling based on user controls, overriding static styles.
         * @param {string} id - The ID for the <style> element (e.g., 'bubbleStyle', 'vividStyle').
         *                     This allows updating the correct style block if it already exists.
         * @param {string} css - The CSS rules string to apply.
         */
        function updateDynamicStyle(id, css) {
            let styleEl = document.getElementById(id);
            if (!styleEl) { // If style element with this ID doesn't exist, create it
                styleEl = document.createElement('style');
                styleEl.id = id; // Assign ID for future updates
                document.head.appendChild(styleEl); // Add to document head
            }
            styleEl.textContent = css; // Set the CSS content of the style element
        }

        /**
         * Updates the connection status display text and style.
         * @param {string} status - The status message (e.g., "Connected", "Disconnected", "Connection Error").
         * @param {boolean} connected - True if successfully connected, false otherwise.
         */
        function updateStatus(status, connected) {
            const statusEl = document.getElementById('status');
            // Display channel name if connected, otherwise just the status.
            statusEl.textContent = status + (connected ? ` to #${currentChannel}` : '');
            // Apply different CSS classes for connected/disconnected states for visual feedback (color).
            statusEl.className = connected ? 'status' : 'status disconnected';
        }

        /**
         * Clears all messages from the chat container by setting its innerHTML to empty.
         */
        function clearChat() {
            document.getElementById('chatContainer').innerHTML = ''; // Remove all child elements
        }
    </script>
</body>
</html>
